{"version":3,"file":"static/webpack/static/development/pages/bar.js.05ccacf2dab675609002.hot-update.js","sources":["webpack:///./components/sectorBar.js","webpack:///./node_modules/@nivo/axes/cjs/nivo-axes.js","webpack:///./node_modules/@nivo/axes/index.js","webpack:///./node_modules/@nivo/bar/cjs/nivo-bar.js","webpack:///./node_modules/@nivo/bar/index.js","webpack:///./node_modules/lodash/_baseExtremum.js","webpack:///./node_modules/lodash/_baseGt.js","webpack:///./node_modules/lodash/_baseLt.js","webpack:///./node_modules/lodash/_baseRange.js","webpack:///./node_modules/lodash/_createRange.js","webpack:///./node_modules/lodash/flattenDepth.js","webpack:///./node_modules/lodash/max.js","webpack:///./node_modules/lodash/min.js","webpack:///./node_modules/lodash/range.js","webpack:///./pages/bar.js"],"sourcesContent":["import { render } from 'react-dom'\nimport { ResponsiveBar } from '@nivo/bar'\n\nconst data = [\n  {\n    \"country\": \"AD\",\n    \"hot dog\": 88,\n    \"hot dogColor\": \"hsl(355, 70%, 50%)\",\n    \"burger\": 84,\n    \"burgerColor\": \"hsl(83, 70%, 50%)\",\n    \"sandwich\": 17,\n    \"sandwichColor\": \"hsl(321, 70%, 50%)\",\n    \"kebab\": 149,\n    \"kebabColor\": \"hsl(15, 70%, 50%)\",\n    \"fries\": 94,\n    \"friesColor\": \"hsl(125, 70%, 50%)\",\n    \"donut\": 167,\n    \"donutColor\": \"hsl(300, 70%, 50%)\"\n  },\n  {\n    \"country\": \"AE\",\n    \"hot dog\": 78,\n    \"hot dogColor\": \"hsl(99, 70%, 50%)\",\n    \"burger\": 158,\n    \"burgerColor\": \"hsl(334, 70%, 50%)\",\n    \"sandwich\": 18,\n    \"sandwichColor\": \"hsl(271, 70%, 50%)\",\n    \"kebab\": 89,\n    \"kebabColor\": \"hsl(262, 70%, 50%)\",\n    \"fries\": 0,\n    \"friesColor\": \"hsl(306, 70%, 50%)\",\n    \"donut\": 181,\n    \"donutColor\": \"hsl(232, 70%, 50%)\"\n  },\n  {\n    \"country\": \"AF\",\n    \"hot dog\": 59,\n    \"hot dogColor\": \"hsl(128, 70%, 50%)\",\n    \"burger\": 51,\n    \"burgerColor\": \"hsl(185, 70%, 50%)\",\n    \"sandwich\": 49,\n    \"sandwichColor\": \"hsl(148, 70%, 50%)\",\n    \"kebab\": 7,\n    \"kebabColor\": \"hsl(261, 70%, 50%)\",\n    \"fries\": 1,\n    \"friesColor\": \"hsl(187, 70%, 50%)\",\n    \"donut\": 91,\n    \"donutColor\": \"hsl(60, 70%, 50%)\"\n  },\n  {\n    \"country\": \"AG\",\n    \"hot dog\": 71,\n    \"hot dogColor\": \"hsl(159, 70%, 50%)\",\n    \"burger\": 115,\n    \"burgerColor\": \"hsl(168, 70%, 50%)\",\n    \"sandwich\": 94,\n    \"sandwichColor\": \"hsl(142, 70%, 50%)\",\n    \"kebab\": 18,\n    \"kebabColor\": \"hsl(233, 70%, 50%)\",\n    \"fries\": 195,\n    \"friesColor\": \"hsl(342, 70%, 50%)\",\n    \"donut\": 102,\n    \"donutColor\": \"hsl(226, 70%, 50%)\"\n  },\n  {\n    \"country\": \"AI\",\n    \"hot dog\": 136,\n    \"hot dogColor\": \"hsl(240, 70%, 50%)\",\n    \"burger\": 82,\n    \"burgerColor\": \"hsl(325, 70%, 50%)\",\n    \"sandwich\": 39,\n    \"sandwichColor\": \"hsl(318, 70%, 50%)\",\n    \"kebab\": 105,\n    \"kebabColor\": \"hsl(282, 70%, 50%)\",\n    \"fries\": 104,\n    \"friesColor\": \"hsl(111, 70%, 50%)\",\n    \"donut\": 107,\n    \"donutColor\": \"hsl(53, 70%, 50%)\"\n  },\n  {\n    \"country\": \"AL\",\n    \"hot dog\": 73,\n    \"hot dogColor\": \"hsl(119, 70%, 50%)\",\n    \"burger\": 4,\n    \"burgerColor\": \"hsl(14, 70%, 50%)\",\n    \"sandwich\": 109,\n    \"sandwichColor\": \"hsl(67, 70%, 50%)\",\n    \"kebab\": 155,\n    \"kebabColor\": \"hsl(239, 70%, 50%)\",\n    \"fries\": 18,\n    \"friesColor\": \"hsl(251, 70%, 50%)\",\n    \"donut\": 57,\n    \"donutColor\": \"hsl(129, 70%, 50%)\"\n  },\n  {\n    \"country\": \"AM\",\n    \"hot dog\": 101,\n    \"hot dogColor\": \"hsl(35, 70%, 50%)\",\n    \"burger\": 71,\n    \"burgerColor\": \"hsl(308, 70%, 50%)\",\n    \"sandwich\": 176,\n    \"sandwichColor\": \"hsl(29, 70%, 50%)\",\n    \"kebab\": 92,\n    \"kebabColor\": \"hsl(46, 70%, 50%)\",\n    \"fries\": 131,\n    \"friesColor\": \"hsl(213, 70%, 50%)\",\n    \"donut\": 189,\n    \"donutColor\": \"hsl(162, 70%, 50%)\"\n  }\n]\n\nconst sectorBar = () => (\n    <ResponsiveBar\n        data={data}\n        keys={[\n            \"hot dog\",\n            \"burger\",\n            \"sandwich\",\n            \"kebab\",\n            \"fries\",\n            \"donut\"\n        ]}\n        indexBy=\"country\"\n        margin={{\n            \"top\": 50,\n            \"right\": 130,\n            \"bottom\": 50,\n            \"left\": 60\n        }}\n        padding={0.3}\n        colors=\"nivo\"\n        colorBy=\"id\"\n        defs={[\n            {\n                \"id\": \"dots\",\n                \"type\": \"patternDots\",\n                \"background\": \"inherit\",\n                \"color\": \"#38bcb2\",\n                \"size\": 4,\n                \"padding\": 1,\n                \"stagger\": true\n            },\n            {\n                \"id\": \"lines\",\n                \"type\": \"patternLines\",\n                \"background\": \"inherit\",\n                \"color\": \"#eed312\",\n                \"rotation\": -45,\n                \"lineWidth\": 6,\n                \"spacing\": 10\n            }\n        ]}\n        fill={[\n            {\n                \"match\": {\n                    \"id\": \"fries\"\n                },\n                \"id\": \"dots\"\n            },\n            {\n                \"match\": {\n                    \"id\": \"sandwich\"\n                },\n                \"id\": \"lines\"\n            }\n        ]}\n        borderColor=\"inherit:darker(1.6)\"\n        axisTop={null}\n        axisRight={null}\n        axisBottom={{\n            \"tickSize\": 5,\n            \"tickPadding\": 5,\n            \"tickRotation\": 0,\n            \"legend\": \"country\",\n            \"legendPosition\": \"middle\",\n            \"legendOffset\": 32\n        }}\n        axisLeft={{\n            \"tickSize\": 5,\n            \"tickPadding\": 5,\n            \"tickRotation\": 0,\n            \"legend\": \"food\",\n            \"legendPosition\": \"middle\",\n            \"legendOffset\": -40\n        }}\n        labelSkipWidth={12}\n        labelSkipHeight={12}\n        labelTextColor=\"inherit:darker(1.6)\"\n        animate={true}\n        motionStiffness={90}\n        motionDamping={15}\n        legends={[\n            {\n                \"dataFrom\": \"keys\",\n                \"anchor\": \"bottom-right\",\n                \"direction\": \"column\",\n                \"justify\": false,\n                \"translateX\": 120,\n                \"translateY\": 0,\n                \"itemsSpacing\": 2,\n                \"itemWidth\": 100,\n                \"itemHeight\": 20,\n                \"itemDirection\": \"left-to-right\",\n                \"itemOpacity\": 0.85,\n                \"symbolSize\": 20,\n                \"effects\": [\n                    {\n                        \"on\": \"hover\",\n                        \"style\": {\n                            \"itemOpacity\": 1\n                        }\n                    }\n                ]\n            }\n        ]}\n    />\n)\n\nexport default sectorBar\n","'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nfunction _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }\n\nvar isNumber = _interopDefault(require('lodash/isNumber'));\nvar isArray = _interopDefault(require('lodash/isArray'));\nvar isFunction = _interopDefault(require('lodash/isFunction'));\nvar d3TimeFormat = require('d3-time-format');\nvar d3Format = require('d3-format');\nvar core = require('@nivo/core');\nvar React = require('react');\nvar React__default = _interopDefault(React);\nvar PropTypes = _interopDefault(require('prop-types'));\nvar compose = _interopDefault(require('recompose/compose'));\nvar withPropsOnChange = _interopDefault(require('recompose/withPropsOnChange'));\nvar pure = _interopDefault(require('recompose/pure'));\nvar setDisplayName = _interopDefault(require('recompose/setDisplayName'));\nvar reactMotion = require('react-motion');\n\nvar classCallCheck = function (instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n};\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nvar inherits = function (subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n};\n\nvar possibleConstructorReturn = function (self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n};\n\nvar centerScale = function centerScale(scale) {\n    var bandwidth = scale.bandwidth();\n\n    if (bandwidth === 0) return scale;\n\n    var offset = bandwidth / 2;\n    if (scale.round()) {\n        offset = Math.round(offset);\n    }\n\n    return function (d) {\n        return scale(d) + offset;\n    };\n};\n\nvar getScaleTicks = function getScaleTicks(scale, tickCount) {\n    if (scale.ticks) return scale.ticks(tickCount);\n    return scale.domain();\n};\n\nvar computeCartesianTicks = function computeCartesianTicks(_ref) {\n    var axis = _ref.axis,\n        scale = _ref.scale,\n        ticksPosition = _ref.ticksPosition,\n        _tickValues = _ref.tickValues,\n        tickSize = _ref.tickSize,\n        tickPadding = _ref.tickPadding,\n        tickRotation = _ref.tickRotation,\n        _ref$engine = _ref.engine,\n        engine = _ref$engine === undefined ? 'svg' : _ref$engine;\n\n    var tickValues = isArray(_tickValues) ? _tickValues : undefined;\n    var tickCount = isNumber(_tickValues) ? _tickValues : undefined;\n\n    var values = tickValues || getScaleTicks(scale, tickCount);\n\n    var textProps = core.textPropsByEngine[engine];\n\n    var position = scale.bandwidth ? centerScale(scale) : scale;\n    var line = { lineX: 0, lineY: 0 };\n    var text = { textX: 0, textY: 0 };\n\n    var translate = void 0;\n    var textAlign = textProps.align.center;\n    var textBaseline = textProps.baseline.center;\n\n    if (axis === 'x') {\n        translate = function translate(d) {\n            return { x: position(d), y: 0 };\n        };\n\n        line.lineY = tickSize * (ticksPosition === 'after' ? 1 : -1);\n        text.textY = (tickSize + tickPadding) * (ticksPosition === 'after' ? 1 : -1);\n\n        if (ticksPosition === 'after') {\n            textBaseline = textProps.baseline.top;\n        } else {\n            textBaseline = textProps.baseline.bottom;\n        }\n\n        if (tickRotation === 0) {\n            textAlign = textProps.align.center;\n        } else if (ticksPosition === 'after' && tickRotation < 0 || ticksPosition === 'before' && tickRotation > 0) {\n            textAlign = textProps.align.right;\n            textBaseline = textProps.baseline.center;\n        } else if (ticksPosition === 'after' && tickRotation > 0 || ticksPosition === 'before' && tickRotation < 0) {\n            textAlign = textProps.align.left;\n            textBaseline = textProps.baseline.center;\n        }\n    } else {\n        translate = function translate(d) {\n            return { x: 0, y: position(d) };\n        };\n\n        line.lineX = tickSize * (ticksPosition === 'after' ? 1 : -1);\n        text.textX = (tickSize + tickPadding) * (ticksPosition === 'after' ? 1 : -1);\n\n        if (ticksPosition === 'after') {\n            textAlign = textProps.align.left;\n        } else {\n            textAlign = textProps.align.right;\n        }\n    }\n\n    var ticks = values.map(function (value) {\n        return _extends({\n            key: value,\n            value: value\n        }, translate(value), line, text);\n    });\n\n    return {\n        ticks: ticks,\n        textAlign: textAlign,\n        textBaseline: textBaseline\n    };\n};\n\nvar getFormatter = function getFormatter(format, scale) {\n    if (!format || isFunction(format)) return format;\n\n    if (scale.type === 'time') {\n        var f = d3TimeFormat.timeFormat(format);\n        return function (d) {\n            return f(new Date(d));\n        };\n    }\n\n    return d3Format.format(format);\n};\n\nvar AxisTick = function (_PureComponent) {\n    inherits(AxisTick, _PureComponent);\n\n    function AxisTick() {\n        classCallCheck(this, AxisTick);\n        return possibleConstructorReturn(this, _PureComponent.apply(this, arguments));\n    }\n\n    AxisTick.prototype.render = function render() {\n        var _props = this.props,\n            _value = _props.value,\n            x = _props.x,\n            y = _props.y,\n            opacity = _props.opacity,\n            rotate = _props.rotate,\n            format = _props.format,\n            lineX = _props.lineX,\n            lineY = _props.lineY,\n            _onClick = _props.onClick,\n            textX = _props.textX,\n            textY = _props.textY,\n            textBaseline = _props.textBaseline,\n            textAnchor = _props.textAnchor,\n            theme = _props.theme;\n\n\n        var value = _value;\n        if (format !== undefined) {\n            value = format(value);\n        }\n\n        var gStyle = { opacity: opacity };\n        if (_onClick) {\n            gStyle['cursor'] = 'pointer';\n        }\n\n        return React__default.createElement(\n            'g',\n            _extends({\n                transform: 'translate(' + x + ',' + y + ')'\n            }, _onClick ? { onClick: function onClick(e) {\n                    return _onClick(e, value);\n                } } : {}, {\n                style: gStyle\n            }),\n            React__default.createElement('line', { x1: 0, x2: lineX, y1: 0, y2: lineY, style: theme.axis.ticks.line }),\n            React__default.createElement(\n                'text',\n                {\n                    alignmentBaseline: textBaseline,\n                    textAnchor: textAnchor,\n                    transform: 'translate(' + textX + ',' + textY + ') rotate(' + rotate + ')',\n                    style: theme.axis.ticks.text\n                },\n                value\n            )\n        );\n    };\n\n    return AxisTick;\n}(React.PureComponent);\n\nAxisTick.propTypes = {\n    value: PropTypes.oneOfType([PropTypes.number, PropTypes.string, PropTypes.instanceOf(Date)]).isRequired,\n    format: PropTypes.func,\n    x: PropTypes.number.isRequired,\n    y: PropTypes.number.isRequired,\n    lineX: PropTypes.number.isRequired,\n    lineY: PropTypes.number.isRequired,\n    textX: PropTypes.number.isRequired,\n    textY: PropTypes.number.isRequired,\n    textBaseline: PropTypes.string.isRequired,\n    textAnchor: PropTypes.string.isRequired,\n    opacity: PropTypes.number.isRequired,\n    rotate: PropTypes.number.isRequired,\n    onClick: PropTypes.func,\n    theme: PropTypes.shape({\n        axis: core.axisThemePropType.isRequired\n    }).isRequired\n};\nAxisTick.defaultProps = {\n    opacity: 1,\n    rotate: 0\n};\n\nvar willEnter = function willEnter() {\n    return {\n        rotate: 0,\n        opacity: 0,\n        x: 0,\n        y: 0\n    };\n};\n\nvar willLeave = function willLeave(springConfig) {\n    return function (_ref) {\n        var _ref$style = _ref.style,\n            x = _ref$style.x,\n            y = _ref$style.y,\n            rotate = _ref$style.rotate;\n        return {\n            rotate: rotate,\n            opacity: reactMotion.spring(0, springConfig),\n            x: reactMotion.spring(x.val, springConfig),\n            y: reactMotion.spring(y.val, springConfig)\n        };\n    };\n};\n\nvar defaultTickRenderer = function defaultTickRenderer(props) {\n    return React__default.createElement(AxisTick, props);\n};\n\nvar Axis = function (_Component) {\n    inherits(Axis, _Component);\n\n    function Axis() {\n        classCallCheck(this, Axis);\n        return possibleConstructorReturn(this, _Component.apply(this, arguments));\n    }\n\n    Axis.prototype.render = function render() {\n        var _props = this.props,\n            axis = _props.axis,\n            scale = _props.scale,\n            x = _props.x,\n            y = _props.y,\n            length = _props.length,\n            ticksPosition = _props.ticksPosition,\n            tickValues = _props.tickValues,\n            tickSize = _props.tickSize,\n            tickPadding = _props.tickPadding,\n            tickRotation = _props.tickRotation,\n            format = _props.format,\n            renderTick = _props.renderTick,\n            legend = _props.legend,\n            legendPosition = _props.legendPosition,\n            legendOffset = _props.legendOffset,\n            theme = _props.theme,\n            animate = _props.animate,\n            motionStiffness = _props.motionStiffness,\n            motionDamping = _props.motionDamping,\n            onClick = _props.onClick;\n\n        var _computeCartesianTick = computeCartesianTicks({\n            axis: axis,\n            scale: scale,\n            ticksPosition: ticksPosition,\n            tickValues: tickValues,\n            tickSize: tickSize,\n            tickPadding: tickPadding,\n            tickRotation: tickRotation\n        }),\n            ticks = _computeCartesianTick.ticks,\n            textAlign = _computeCartesianTick.textAlign,\n            textBaseline = _computeCartesianTick.textBaseline;\n\n        var legendNode = null;\n        if (legend !== undefined) {\n            var legendX = 0;\n            var legendY = 0;\n            var legendRotation = 0;\n            var textAnchor = void 0;\n\n            if (axis === 'y') {\n                legendRotation = -90;\n                legendX = legendOffset;\n                if (legendPosition === 'start') {\n                    textAnchor = 'start';\n                    legendY = length;\n                } else if (legendPosition === 'middle') {\n                    textAnchor = 'middle';\n                    legendY = length / 2;\n                } else if (legendPosition === 'end') {\n                    textAnchor = 'end';\n                }\n            } else {\n                legendY = legendOffset;\n                if (legendPosition === 'start') {\n                    textAnchor = 'start';\n                } else if (legendPosition === 'middle') {\n                    textAnchor = 'middle';\n                    legendX = length / 2;\n                } else if (legendPosition === 'end') {\n                    textAnchor = 'end';\n                    legendX = length;\n                }\n            }\n\n            legendNode = React__default.createElement(\n                'text',\n                {\n                    transform: 'translate(' + legendX + ', ' + legendY + ') rotate(' + legendRotation + ')',\n                    textAnchor: textAnchor,\n                    style: _extends({\n                        alignmentBaseline: 'middle'\n                    }, theme.axis.legend.text)\n                },\n                legend\n            );\n        }\n\n        if (animate !== true) {\n            return React__default.createElement(\n                'g',\n                { transform: 'translate(' + x + ',' + y + ')' },\n                ticks.map(function (tick, tickIndex) {\n                    return renderTick(_extends({\n                        tickIndex: tickIndex,\n                        format: format,\n                        rotate: tickRotation,\n                        textBaseline: textBaseline,\n                        textAnchor: textAlign,\n                        theme: theme\n                    }, tick, onClick ? { onClick: onClick } : {}));\n                }),\n                React__default.createElement('line', {\n                    style: theme.axis.domain.line,\n                    x1: 0,\n                    x2: axis === 'x' ? length : 0,\n                    y1: 0,\n                    y2: axis === 'x' ? 0 : length\n                }),\n                legendNode\n            );\n        }\n\n        var springConfig = {\n            stiffness: motionStiffness,\n            damping: motionDamping\n        };\n\n        return React__default.createElement(\n            reactMotion.Motion,\n            { style: { x: reactMotion.spring(x, springConfig), y: reactMotion.spring(y, springConfig) } },\n            function (xy) {\n                return React__default.createElement(\n                    'g',\n                    { transform: 'translate(' + xy.x + ',' + xy.y + ')' },\n                    React__default.createElement(\n                        reactMotion.TransitionMotion,\n                        {\n                            willEnter: willEnter,\n                            willLeave: willLeave(springConfig),\n                            styles: ticks.map(function (tick) {\n                                return {\n                                    key: '' + tick.key,\n                                    data: tick,\n                                    style: {\n                                        opacity: reactMotion.spring(1, springConfig),\n                                        x: reactMotion.spring(tick.x, springConfig),\n                                        y: reactMotion.spring(tick.y, springConfig),\n                                        rotate: reactMotion.spring(tickRotation, springConfig)\n                                    }\n                                };\n                            })\n                        },\n                        function (interpolatedStyles) {\n                            return React__default.createElement(\n                                React.Fragment,\n                                null,\n                                interpolatedStyles.map(function (_ref2, tickIndex) {\n                                    var style = _ref2.style,\n                                        tick = _ref2.data;\n                                    return renderTick(_extends({\n                                        tickIndex: tickIndex,\n                                        format: format,\n                                        textBaseline: textBaseline,\n                                        textAnchor: textAlign,\n                                        theme: theme\n                                    }, tick, style, onClick ? { onClick: onClick } : {}));\n                                })\n                            );\n                        }\n                    ),\n                    React__default.createElement(\n                        reactMotion.Motion,\n                        {\n                            style: {\n                                x2: reactMotion.spring(axis === 'x' ? length : 0, springConfig),\n                                y2: reactMotion.spring(axis === 'x' ? 0 : length, springConfig)\n                            }\n                        },\n                        function (values) {\n                            return React__default.createElement('line', _extends({ style: theme.axis.domain.line, x1: 0, y1: 0 }, values));\n                        }\n                    ),\n                    legendNode\n                );\n            }\n        );\n    };\n\n    return Axis;\n}(React.Component);\n\nAxis.propTypes = _extends({\n    axis: PropTypes.oneOf(['x', 'y']).isRequired,\n    scale: PropTypes.func.isRequired,\n    x: PropTypes.number.isRequired,\n    y: PropTypes.number.isRequired,\n    length: PropTypes.number.isRequired,\n    ticksPosition: PropTypes.oneOf(['before', 'after']).isRequired,\n    tickValues: PropTypes.oneOfType([PropTypes.number, PropTypes.arrayOf(PropTypes.oneOfType([PropTypes.number, PropTypes.string, PropTypes.instanceOf(Date)]))]),\n    tickSize: PropTypes.number.isRequired,\n    tickPadding: PropTypes.number.isRequired,\n    tickRotation: PropTypes.number.isRequired,\n    tickFormat: PropTypes.oneOfType([PropTypes.func, PropTypes.string]),\n    renderTick: PropTypes.func.isRequired,\n    legend: PropTypes.node,\n    legendPosition: PropTypes.oneOf(['start', 'middle', 'end']).isRequired,\n    legendOffset: PropTypes.number.isRequired,\n    theme: PropTypes.shape({\n        axis: core.axisThemePropType.isRequired\n    }).isRequired\n}, core.motionPropTypes);\nAxis.defaultProps = {\n    x: 0,\n    y: 0,\n    tickSize: 5,\n    tickPadding: 5,\n    tickRotation: 0,\n    renderTick: defaultTickRenderer,\n    legendPosition: 'end',\n    legendOffset: 0\n};\n\n\nvar enhance = compose(core.withMotion(), withPropsOnChange(['format', 'scale'], function (_ref3) {\n    var format = _ref3.format,\n        scale = _ref3.scale;\n    return {\n        format: getFormatter(format, scale)\n    };\n}), pure);\n\nvar Axis$1 = setDisplayName('Axis')(enhance(Axis));\n\nvar axisPropTypes = {\n    ticksPosition: PropTypes.oneOf(['before', 'after']),\n    tickValues: PropTypes.oneOfType([PropTypes.number, PropTypes.arrayOf(PropTypes.oneOfType([PropTypes.number, PropTypes.string, PropTypes.instanceOf(Date)]))]),\n    tickSize: PropTypes.number,\n    tickPadding: PropTypes.number,\n    tickRotation: PropTypes.number,\n    format: PropTypes.oneOfType([PropTypes.func, PropTypes.string]),\n    renderTick: PropTypes.func,\n    legend: PropTypes.node,\n    legendPosition: PropTypes.oneOf(['start', 'middle', 'end']),\n    legendOffset: PropTypes.number\n};\n\nvar axisPropType = PropTypes.shape(axisPropTypes);\n\nvar positions = ['top', 'right', 'bottom', 'left'];\n\nvar Axes = function (_PureComponent) {\n    inherits(Axes, _PureComponent);\n\n    function Axes() {\n        classCallCheck(this, Axes);\n        return possibleConstructorReturn(this, _PureComponent.apply(this, arguments));\n    }\n\n    Axes.prototype.render = function render() {\n        var _props = this.props,\n            xScale = _props.xScale,\n            yScale = _props.yScale,\n            width = _props.width,\n            height = _props.height,\n            top = _props.top,\n            right = _props.right,\n            bottom = _props.bottom,\n            left = _props.left,\n            theme = _props.theme,\n            animate = _props.animate,\n            motionStiffness = _props.motionStiffness,\n            motionDamping = _props.motionDamping;\n\n\n        var axes = { top: top, right: right, bottom: bottom, left: left };\n\n        return React__default.createElement(\n            React.Fragment,\n            null,\n            positions.map(function (position) {\n                var axis = axes[position];\n\n                if (!axis) return null;\n\n                var isXAxis = position === 'top' || position === 'bottom';\n                var ticksPosition = position === 'top' || position === 'left' ? 'before' : 'after';\n\n                return React__default.createElement(Axis$1, _extends({\n                    key: position\n                }, axis, {\n                    axis: isXAxis ? 'x' : 'y',\n                    x: position === 'right' ? width : 0,\n                    y: position === 'bottom' ? height : 0,\n                    scale: isXAxis ? xScale : yScale,\n                    length: isXAxis ? width : height,\n                    ticksPosition: ticksPosition,\n                    theme: theme,\n                    animate: animate,\n                    motionDamping: motionDamping,\n                    motionStiffness: motionStiffness\n                }));\n            })\n        );\n    };\n\n    return Axes;\n}(React.PureComponent);\n\nAxes.propTypes = _extends({\n    xScale: PropTypes.func.isRequired,\n    yScale: PropTypes.func.isRequired,\n    width: PropTypes.number.isRequired,\n    height: PropTypes.number.isRequired,\n    top: axisPropType,\n    right: axisPropType,\n    bottom: axisPropType,\n    left: axisPropType,\n    theme: PropTypes.shape({\n        axis: core.axisThemePropType.isRequired\n    }).isRequired\n}, core.motionPropTypes);\n\nvar degreesToRadians = function degreesToRadians(degrees) {\n  return degrees * Math.PI / 180;\n};\n\nvar renderAxisToCanvas = function renderAxisToCanvas(ctx, _ref) {\n    var axis = _ref.axis,\n        scale = _ref.scale,\n        _ref$x = _ref.x,\n        x = _ref$x === undefined ? 0 : _ref$x,\n        _ref$y = _ref.y,\n        y = _ref$y === undefined ? 0 : _ref$y,\n        length = _ref.length,\n        ticksPosition = _ref.ticksPosition,\n        tickValues = _ref.tickValues,\n        _ref$tickSize = _ref.tickSize,\n        tickSize = _ref$tickSize === undefined ? 5 : _ref$tickSize,\n        _ref$tickPadding = _ref.tickPadding,\n        tickPadding = _ref$tickPadding === undefined ? 5 : _ref$tickPadding,\n        _ref$tickRotation = _ref.tickRotation,\n        tickRotation = _ref$tickRotation === undefined ? 0 : _ref$tickRotation,\n        format = _ref.format,\n        theme = _ref.theme;\n\n    var _computeCartesianTick = computeCartesianTicks({\n        axis: axis,\n        scale: scale,\n        ticksPosition: ticksPosition,\n        tickValues: tickValues,\n        tickSize: tickSize,\n        tickPadding: tickPadding,\n        tickRotation: tickRotation,\n        engine: 'canvas'\n    }),\n        ticks = _computeCartesianTick.ticks,\n        textAlign = _computeCartesianTick.textAlign,\n        textBaseline = _computeCartesianTick.textBaseline;\n\n    ctx.save();\n    ctx.translate(x, y);\n\n    ctx.textAlign = textAlign;\n    ctx.textBaseline = textBaseline;\n    ctx.font = theme.axis.ticks.text.fontSize + 'px sans-serif';\n\n    ctx.lineWidth = theme.axis.domain.line.strokeWidth;\n    ctx.lineCap = 'square';\n    ctx.strokeStyle = theme.axis.domain.line.stroke;\n    ctx.beginPath();\n    ctx.moveTo(0, 0);\n    ctx.lineTo(axis === 'x' ? length : 0, axis === 'x' ? 0 : length);\n    ctx.stroke();\n\n    ticks.forEach(function (tick) {\n        ctx.lineWidth = theme.axis.ticks.line.strokeWidth;\n        ctx.lineCap = 'square';\n        ctx.strokeStyle = theme.axis.ticks.line.stroke;\n        ctx.beginPath();\n        ctx.moveTo(tick.x, tick.y);\n        ctx.lineTo(tick.x + tick.lineX, tick.y + tick.lineY);\n        ctx.stroke();\n\n        var value = format !== undefined ? format(tick.value) : tick.value;\n\n        ctx.save();\n        ctx.translate(tick.x + tick.textX, tick.y + tick.textY);\n        ctx.rotate(degreesToRadians(tickRotation));\n        ctx.fillStyle = theme.axis.ticks.text.fill;\n        ctx.fillText(value, 0, 0);\n        ctx.restore();\n    });\n\n    ctx.restore();\n};\n\nvar positions$1 = ['top', 'right', 'bottom', 'left'];\n\nvar renderAxesToCanvas = function renderAxesToCanvas(ctx, _ref2) {\n    var xScale = _ref2.xScale,\n        yScale = _ref2.yScale,\n        width = _ref2.width,\n        height = _ref2.height,\n        top = _ref2.top,\n        right = _ref2.right,\n        bottom = _ref2.bottom,\n        left = _ref2.left,\n        theme = _ref2.theme;\n\n    var axes = { top: top, right: right, bottom: bottom, left: left };\n\n    positions$1.forEach(function (position) {\n        var axis = axes[position];\n\n        if (!axis) return null;\n\n        var isXAxis = position === 'top' || position === 'bottom';\n        var ticksPosition = position === 'top' || position === 'left' ? 'before' : 'after';\n        var scale = isXAxis ? xScale : yScale;\n        var format = getFormatter(axis.format, scale);\n\n        renderAxisToCanvas(ctx, _extends({}, axis, {\n            axis: isXAxis ? 'x' : 'y',\n            x: position === 'right' ? width : 0,\n            y: position === 'bottom' ? height : 0,\n            scale: scale,\n            format: format,\n            length: isXAxis ? width : height,\n            ticksPosition: ticksPosition,\n            theme: theme\n        }));\n    });\n};\n\nexports.Axes = Axes;\nexports.Axis = Axis$1;\nexports.renderAxisToCanvas = renderAxisToCanvas;\nexports.renderAxesToCanvas = renderAxesToCanvas;\nexports.axisPropTypes = axisPropTypes;\nexports.axisPropType = axisPropType;\n","module.exports = require('./cjs/nivo-axes')\n","'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nfunction _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }\n\nvar d3Scale = require('d3-scale');\nvar min = _interopDefault(require('lodash/min'));\nvar max = _interopDefault(require('lodash/max'));\nvar range = _interopDefault(require('lodash/range'));\nvar flattenDepth = _interopDefault(require('lodash/flattenDepth'));\nvar d3Shape = require('d3-shape');\nvar React = require('react');\nvar React__default = _interopDefault(React);\nvar PropTypes = _interopDefault(require('prop-types'));\nvar compose = _interopDefault(require('recompose/compose'));\nvar withPropsOnChange = _interopDefault(require('recompose/withPropsOnChange'));\nvar pure = _interopDefault(require('recompose/pure'));\nvar core = require('@nivo/core');\nvar axes = require('@nivo/axes');\nvar legends = require('@nivo/legends');\nvar defaultProps = _interopDefault(require('recompose/defaultProps'));\nvar reactMotion = require('react-motion');\nvar setDisplayName = _interopDefault(require('recompose/setDisplayName'));\n\n/**\n * Generates indexed scale.\n *\n * @param {Array.<Object>} data\n * @param {Function}       getIndex\n * @param {Array.<number>} range\n * @param {number}         padding\n * @returns {Function}\n */\nvar getIndexedScale = function getIndexedScale(data, getIndex, range$$1, padding) {\n  return d3Scale.scaleBand().rangeRound(range$$1).domain(data.map(getIndex)).padding(padding);\n};\n\n/**\n * Generates scale for grouped bar chart.\n *\n * @param {Array.<Object>} data\n * @param {Array.<string>} keys\n * @param {number}         _minValue\n * @param {number|string}  _maxValue\n * @param {Array.<number>} range\n * @returns {Function}\n */\nvar getGroupedScale = function getGroupedScale(data, keys, _minValue, _maxValue, range$$1) {\n    var allValues = data.reduce(function (acc, entry) {\n        return [].concat(acc, keys.map(function (k) {\n            return entry[k];\n        }));\n    }, []);\n\n    var maxValue = _maxValue;\n    if (maxValue === 'auto') {\n        maxValue = max(allValues);\n    }\n\n    var minValue = _minValue;\n    if (minValue === 'auto') {\n        minValue = min(allValues);\n        if (minValue > 0) minValue = 0;\n    }\n\n    return d3Scale.scaleLinear().rangeRound(range$$1).domain([minValue, maxValue]);\n};\n\n/**\n * Generates x/y scales & bars for vertical grouped bar chart.\n *\n * @param {Array.<Object>} data\n * @param {Function}       getIndex\n * @param {Array.<string>} keys\n * @param {number}         minValue\n * @param {number}         maxValue\n * @param {boolean}        reverse\n * @param {number}         width\n * @param {number}         height\n * @param {Function}       getColor\n * @param {number}         [padding=0]\n * @param {number}         [innerPadding=0]\n * @return {{ xScale: Function, yScale: Function, bars: Array.<Object> }}\n */\nvar generateVerticalGroupedBars = function generateVerticalGroupedBars(_ref) {\n    var data = _ref.data,\n        getIndex = _ref.getIndex,\n        keys = _ref.keys,\n        minValue = _ref.minValue,\n        maxValue = _ref.maxValue,\n        reverse = _ref.reverse,\n        width = _ref.width,\n        height = _ref.height,\n        getColor = _ref.getColor,\n        _ref$padding = _ref.padding,\n        padding = _ref$padding === undefined ? 0 : _ref$padding,\n        _ref$innerPadding = _ref.innerPadding,\n        innerPadding = _ref$innerPadding === undefined ? 0 : _ref$innerPadding;\n\n    var xScale = getIndexedScale(data, getIndex, [0, width], padding);\n    var yRange = reverse ? [0, height] : [height, 0];\n    var yScale = getGroupedScale(data, keys, minValue, maxValue, yRange);\n\n    var barWidth = (xScale.bandwidth() - innerPadding * (keys.length - 1)) / keys.length;\n    var yRef = yScale(0);\n\n    var getY = function getY(d) {\n        return d > 0 ? yScale(d) : yRef;\n    };\n    var getHeight = function getHeight(d, y) {\n        return d > 0 ? yRef - y : yScale(d) - yRef;\n    };\n    if (reverse) {\n        getY = function getY(d) {\n            return d < 0 ? yScale(d) : yRef;\n        };\n        getHeight = function getHeight(d, y) {\n            return d < 0 ? yRef - y : yScale(d) - yRef;\n        };\n    }\n\n    var bars = [];\n    if (barWidth > 0) {\n        keys.forEach(function (key, i) {\n            range(xScale.domain().length).forEach(function (index) {\n                var x = xScale(getIndex(data[index])) + barWidth * i + innerPadding * i;\n                var y = getY(data[index][key]);\n                var barHeight = getHeight(data[index][key], y);\n\n                if (barWidth > 0 && barHeight > 0) {\n                    var barData = {\n                        id: key,\n                        value: data[index][key],\n                        index: index,\n                        indexValue: getIndex(data[index]),\n                        data: data[index]\n                    };\n\n                    bars.push({\n                        key: key + '.' + barData.indexValue,\n                        data: barData,\n                        x: x,\n                        y: y,\n                        width: barWidth,\n                        height: barHeight,\n                        color: getColor(barData)\n                    });\n                }\n            });\n        });\n    }\n\n    return { xScale: xScale, yScale: yScale, bars: bars };\n};\n\n/**\n * Generates x/y scales & bars for horizontal grouped bar chart.\n *\n * @param {Array.<Object>} data\n * @param {Function}       getIndex\n * @param {Array.<string>} keys\n * @param {number}         minValue\n * @param {number}         maxValue\n * @param {boolean}        reverse\n * @param {number}         width\n * @param {number}         height\n * @param {Function}       getColor\n * @param {number}         [padding=0]\n * @param {number}         [innerPadding=0]\n * @return {{ xScale: Function, yScale: Function, bars: Array.<Object> }}\n */\nvar generateHorizontalGroupedBars = function generateHorizontalGroupedBars(_ref2) {\n    var data = _ref2.data,\n        getIndex = _ref2.getIndex,\n        keys = _ref2.keys,\n        minValue = _ref2.minValue,\n        maxValue = _ref2.maxValue,\n        reverse = _ref2.reverse,\n        width = _ref2.width,\n        height = _ref2.height,\n        getColor = _ref2.getColor,\n        _ref2$padding = _ref2.padding,\n        padding = _ref2$padding === undefined ? 0 : _ref2$padding,\n        _ref2$innerPadding = _ref2.innerPadding,\n        innerPadding = _ref2$innerPadding === undefined ? 0 : _ref2$innerPadding;\n\n    var xRange = reverse ? [width, 0] : [0, width];\n    var xScale = getGroupedScale(data, keys, minValue, maxValue, xRange);\n    var yScale = getIndexedScale(data, getIndex, [height, 0], padding);\n\n    var barHeight = (yScale.bandwidth() - innerPadding * (keys.length - 1)) / keys.length;\n    var xRef = xScale(0);\n\n    var getX = function getX(d) {\n        return d > 0 ? xRef : xScale(d);\n    };\n    var getWidth = function getWidth(d, x) {\n        return d > 0 ? xScale(d) - xRef : xRef - x;\n    };\n    if (reverse) {\n        getX = function getX(d) {\n            return d < 0 ? xRef : xScale(d);\n        };\n        getWidth = function getWidth(d, x) {\n            return d < 0 ? xScale(d) - xRef : xRef - x;\n        };\n    }\n\n    var bars = [];\n    if (barHeight > 0) {\n        keys.forEach(function (key, i) {\n            range(yScale.domain().length).forEach(function (index) {\n                var x = getX(data[index][key]);\n                var y = yScale(getIndex(data[index])) + barHeight * i + innerPadding * i;\n                var barWidth = getWidth(data[index][key], x);\n\n                if (barWidth > 0) {\n                    var barData = {\n                        id: key,\n                        value: data[index][key],\n                        index: index,\n                        indexValue: getIndex(data[index]),\n                        data: data[index]\n                    };\n\n                    bars.push({\n                        key: key + '.' + barData.indexValue,\n                        data: barData,\n                        x: x,\n                        y: y,\n                        width: barWidth,\n                        height: barHeight,\n                        color: getColor(barData)\n                    });\n                }\n            });\n        });\n    }\n\n    return { xScale: xScale, yScale: yScale, bars: bars };\n};\n\n/**\n * Generates x/y scales & bars for grouped bar chart.\n *\n * @param {Object} options\n * @return {{ xScale: Function, yScale: Function, bars: Array.<Object> }}\n */\nvar generateGroupedBars = function generateGroupedBars(options) {\n    return options.layout === 'vertical' ? generateVerticalGroupedBars(options) : generateHorizontalGroupedBars(options);\n};\n\n/**\n * Generates scale for stacked bar chart.\n *\n * @param {Array.<Object>} data\n * @param {number|string}  _minValue\n * @param {number|string}  _maxValue\n * @param {Array.<number>} range\n * @returns {Function}\n */\nvar getStackedScale = function getStackedScale(data, _minValue, _maxValue, range$$1) {\n    var allValues = flattenDepth(data, 2);\n\n    var minValue = _minValue;\n    if (minValue === 'auto') {\n        minValue = min(allValues);\n    }\n\n    var maxValue = _maxValue;\n    if (maxValue === 'auto') {\n        maxValue = max(allValues);\n    }\n\n    return d3Scale.scaleLinear().rangeRound(range$$1).domain([minValue, maxValue]);\n};\n\n/**\n * Generates x/y scales & bars for vertical stacked bar chart.\n *\n * @param {Array.<Object>} data\n * @param {Function}       getIndex\n * @param {Array.<string>} keys\n * @param {number}         minValue\n * @param {number}         maxValue\n * @param {boolean}        reverse\n * @param {number}         width\n * @param {number}         height\n * @param {Function}       getColor\n * @param {number}         [padding=0]\n * @param {number}         [innerPadding=0]\n * @return {{ xScale: Function, yScale: Function, bars: Array.<Object> }}\n */\nvar generateVerticalStackedBars = function generateVerticalStackedBars(_ref) {\n    var data = _ref.data,\n        getIndex = _ref.getIndex,\n        keys = _ref.keys,\n        minValue = _ref.minValue,\n        maxValue = _ref.maxValue,\n        reverse = _ref.reverse,\n        width = _ref.width,\n        height = _ref.height,\n        getColor = _ref.getColor,\n        _ref$padding = _ref.padding,\n        padding = _ref$padding === undefined ? 0 : _ref$padding,\n        _ref$innerPadding = _ref.innerPadding,\n        innerPadding = _ref$innerPadding === undefined ? 0 : _ref$innerPadding;\n\n    var stackedData = d3Shape.stack().keys(keys).offset(d3Shape.stackOffsetDiverging)(data);\n\n    var xScale = getIndexedScale(data, getIndex, [0, width], padding);\n    var yRange = reverse ? [0, height] : [height, 0];\n    var yScale = getStackedScale(stackedData, minValue, maxValue, yRange);\n\n    var bars = [];\n    var barWidth = xScale.bandwidth();\n\n    var getY = function getY(d) {\n        return yScale(d[1]);\n    };\n    var getHeight = function getHeight(d, y) {\n        return yScale(d[0]) - y;\n    };\n    if (reverse) {\n        getY = function getY(d) {\n            return yScale(d[0]);\n        };\n        getHeight = function getHeight(d, y) {\n            return yScale(d[1]) - y;\n        };\n    }\n\n    if (barWidth > 0) {\n        stackedData.forEach(function (stackedDataItem) {\n            xScale.domain().forEach(function (index, i) {\n                var d = stackedDataItem[i];\n                var x = xScale(getIndex(d.data));\n\n                var y = getY(d);\n                var barHeight = getHeight(d, y);\n                if (innerPadding > 0) {\n                    y += innerPadding * 0.5;\n                    barHeight -= innerPadding;\n                }\n\n                if (barHeight > 0) {\n                    var barData = {\n                        id: stackedDataItem.key,\n                        value: d.data[stackedDataItem.key],\n                        index: i,\n                        indexValue: index,\n                        data: d.data\n                    };\n\n                    bars.push({\n                        key: stackedDataItem.key + '.' + index,\n                        data: barData,\n                        x: x,\n                        y: y,\n                        width: barWidth,\n                        height: barHeight,\n                        color: getColor(barData)\n                    });\n                }\n            });\n        });\n    }\n\n    return { xScale: xScale, yScale: yScale, bars: bars };\n};\n\n/**\n * Generates x/y scales & bars for horizontal stacked bar chart.\n *\n * @param {Array.<Object>} data\n * @param {Function}       getIndex\n * @param {Array.<string>} keys\n * @param {number}         minValue\n * @param {number}         maxValue\n * @param {boolean}        reverse\n * @param {number}         width\n * @param {number}         height\n * @param {Function}       getColor\n * @param {number}         [padding=0]\n * @param {number}         [innerPadding=0]\n * @return {{ xScale: Function, yScale: Function, bars: Array.<Object> }}\n */\nvar generateHorizontalStackedBars = function generateHorizontalStackedBars(_ref2) {\n    var data = _ref2.data,\n        getIndex = _ref2.getIndex,\n        keys = _ref2.keys,\n        minValue = _ref2.minValue,\n        maxValue = _ref2.maxValue,\n        reverse = _ref2.reverse,\n        width = _ref2.width,\n        height = _ref2.height,\n        getColor = _ref2.getColor,\n        _ref2$padding = _ref2.padding,\n        padding = _ref2$padding === undefined ? 0 : _ref2$padding,\n        _ref2$innerPadding = _ref2.innerPadding,\n        innerPadding = _ref2$innerPadding === undefined ? 0 : _ref2$innerPadding;\n\n    var stackedData = d3Shape.stack().keys(keys).offset(d3Shape.stackOffsetDiverging)(data);\n\n    var xRange = reverse ? [width, 0] : [0, width];\n    var xScale = getStackedScale(stackedData, minValue, maxValue, xRange);\n    var yScale = getIndexedScale(data, getIndex, [height, 0], padding);\n\n    var bars = [];\n    var barHeight = yScale.bandwidth();\n\n    var getX = function getX(d) {\n        return xScale(d[0]);\n    };\n    var getWidth = function getWidth(d, x) {\n        return xScale(d[1]) - x;\n    };\n    if (reverse) {\n        getX = function getX(d) {\n            return xScale(d[1]);\n        };\n        getWidth = function getWidth(d, y) {\n            return xScale(d[0]) - y;\n        };\n    }\n\n    if (barHeight > 0) {\n        stackedData.forEach(function (stackedDataItem) {\n            yScale.domain().forEach(function (index, i) {\n                var d = stackedDataItem[i];\n                var y = yScale(getIndex(d.data));\n\n                var barData = {\n                    id: stackedDataItem.key,\n                    value: d.data[stackedDataItem.key],\n                    index: i,\n                    indexValue: index,\n                    data: d.data\n                };\n\n                var x = getX(d);\n                var barWidth = getWidth(d, x);\n                if (innerPadding > 0) {\n                    x += innerPadding * 0.5;\n                    barWidth -= innerPadding;\n                }\n\n                if (barWidth > 0) {\n                    bars.push({\n                        key: stackedDataItem.key + '.' + index,\n                        data: barData,\n                        x: x,\n                        y: y,\n                        width: barWidth,\n                        height: barHeight,\n                        color: getColor(barData)\n                    });\n                }\n            });\n        });\n    }\n\n    return { xScale: xScale, yScale: yScale, bars: bars };\n};\n\n/**\n * Generates x/y scales & bars for stacked bar chart.\n *\n * @param {Object} options\n * @return {{ xScale: Function, yScale: Function, bars: Array.<Object> }}\n */\nvar generateStackedBars = function generateStackedBars(options) {\n    return options.layout === 'vertical' ? generateVerticalStackedBars(options) : generateHorizontalStackedBars(options);\n};\n\nvar classCallCheck = function (instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n};\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nvar inherits = function (subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n};\n\nvar possibleConstructorReturn = function (self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n};\n\nvar BarItem = function BarItem(_ref) {\n    var data = _ref.data,\n        x = _ref.x,\n        y = _ref.y,\n        width = _ref.width,\n        height = _ref.height,\n        borderRadius = _ref.borderRadius,\n        color = _ref.color,\n        borderWidth = _ref.borderWidth,\n        borderColor = _ref.borderColor,\n        label = _ref.label,\n        shouldRenderLabel = _ref.shouldRenderLabel,\n        labelColor = _ref.labelColor,\n        showTooltip = _ref.showTooltip,\n        hideTooltip = _ref.hideTooltip,\n        onClick = _ref.onClick,\n        onMouseEnter = _ref.onMouseEnter,\n        onMouseLeave = _ref.onMouseLeave,\n        tooltip = _ref.tooltip,\n        theme = _ref.theme;\n\n    var handleTooltip = function handleTooltip(e) {\n        return showTooltip(tooltip, e);\n    };\n    var handleMouseEnter = function handleMouseEnter(e) {\n        onMouseEnter(data, e);\n        showTooltip(tooltip, e);\n    };\n    var handleMouseLeave = function handleMouseLeave(e) {\n        onMouseLeave(data, e);\n        hideTooltip(e);\n    };\n\n    return React__default.createElement(\n        'g',\n        { transform: 'translate(' + x + ', ' + y + ')' },\n        React__default.createElement('rect', {\n            width: width,\n            height: height,\n            rx: borderRadius,\n            ry: borderRadius,\n            fill: data.fill ? data.fill : color,\n            strokeWidth: borderWidth,\n            stroke: borderColor,\n            onMouseEnter: handleMouseEnter,\n            onMouseMove: handleTooltip,\n            onMouseLeave: handleMouseLeave,\n            onClick: onClick\n        }),\n        shouldRenderLabel && React__default.createElement(\n            'text',\n            {\n                x: width / 2,\n                y: height / 2,\n                textAnchor: 'middle',\n                alignmentBaseline: 'central',\n                style: _extends({}, theme.labels.text, {\n                    pointerEvents: 'none',\n                    fill: labelColor\n                })\n            },\n            label\n        )\n    );\n};\n\nBarItem.propTypes = {\n    data: PropTypes.shape({\n        id: PropTypes.string.isRequired,\n        value: PropTypes.number.isRequired,\n        indexValue: PropTypes.string.isRequired\n    }).isRequired,\n\n    x: PropTypes.number.isRequired,\n    y: PropTypes.number.isRequired,\n    width: PropTypes.number.isRequired,\n    height: PropTypes.number.isRequired,\n    color: PropTypes.string.isRequired,\n    borderRadius: PropTypes.number.isRequired,\n    borderWidth: PropTypes.number.isRequired,\n    borderColor: PropTypes.string.isRequired,\n\n    label: PropTypes.oneOfType([PropTypes.string, PropTypes.number]).isRequired,\n    shouldRenderLabel: PropTypes.bool.isRequired,\n    labelColor: PropTypes.string.isRequired,\n\n    showTooltip: PropTypes.func.isRequired,\n    hideTooltip: PropTypes.func.isRequired,\n    getTooltipLabel: PropTypes.func.isRequired,\n    tooltipFormat: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),\n    onClick: PropTypes.func,\n    onMouseEnter: PropTypes.func,\n    onMouseLeave: PropTypes.func,\n    tooltip: PropTypes.element.isRequired,\n\n    theme: PropTypes.shape({\n        tooltip: PropTypes.shape({}).isRequired\n    }).isRequired\n};\n\nvar enhance = compose(withPropsOnChange(['data', 'color', 'onClick'], function (_ref2) {\n    var data = _ref2.data,\n        color = _ref2.color,\n        _onClick = _ref2.onClick;\n    return {\n        onClick: function onClick(event) {\n            return _onClick(_extends({ color: color }, data), event);\n        }\n    };\n}), withPropsOnChange(['data', 'color', 'theme', 'tooltip', 'getTooltipLabel', 'tooltipFormat'], function (_ref3) {\n    var data = _ref3.data,\n        color = _ref3.color,\n        theme = _ref3.theme,\n        tooltip = _ref3.tooltip,\n        getTooltipLabel = _ref3.getTooltipLabel,\n        tooltipFormat = _ref3.tooltipFormat;\n    return {\n        tooltip: React__default.createElement(core.BasicTooltip, {\n            id: getTooltipLabel(data),\n            value: data.value,\n            enableChip: true,\n            color: color,\n            theme: theme,\n            format: tooltipFormat,\n            renderContent: typeof tooltip === 'function' ? tooltip.bind(null, _extends({ color: color, theme: theme }, data)) : null\n        })\n    };\n}), pure);\n\nvar BarItem$1 = enhance(BarItem);\n\nvar BarPropTypes = _extends({\n    data: PropTypes.arrayOf(PropTypes.object).isRequired,\n    indexBy: PropTypes.oneOfType([PropTypes.string, PropTypes.func]).isRequired,\n    getIndex: PropTypes.func.isRequired, // computed\n    keys: PropTypes.arrayOf(PropTypes.oneOfType([PropTypes.string, PropTypes.number])).isRequired,\n    layers: PropTypes.arrayOf(PropTypes.oneOfType([PropTypes.oneOf(['grid', 'axes', 'bars', 'markers', 'legends']), PropTypes.func])).isRequired,\n\n    groupMode: PropTypes.oneOf(['stacked', 'grouped']).isRequired,\n    layout: PropTypes.oneOf(['horizontal', 'vertical']).isRequired,\n    reverse: PropTypes.bool.isRequired,\n\n    minValue: PropTypes.oneOfType([PropTypes.number, PropTypes.oneOf(['auto'])]).isRequired,\n    maxValue: PropTypes.oneOfType([PropTypes.number, PropTypes.oneOf(['auto'])]).isRequired,\n    padding: PropTypes.number.isRequired,\n    innerPadding: PropTypes.number.isRequired,\n\n    axisTop: axes.axisPropType,\n    axisRight: axes.axisPropType,\n    axisBottom: axes.axisPropType,\n    axisLeft: axes.axisPropType,\n    enableGridX: PropTypes.bool.isRequired,\n    enableGridY: PropTypes.bool.isRequired,\n    gridXValues: PropTypes.arrayOf(PropTypes.number),\n    gridYValues: PropTypes.arrayOf(PropTypes.number),\n\n    barComponent: PropTypes.func.isRequired,\n\n    enableLabel: PropTypes.bool.isRequired,\n    label: PropTypes.oneOfType([PropTypes.string, PropTypes.func]).isRequired,\n    labelFormat: PropTypes.oneOfType([PropTypes.string, PropTypes.func]),\n    getLabel: PropTypes.func.isRequired, // computed\n    labelSkipWidth: PropTypes.number.isRequired,\n    labelSkipHeight: PropTypes.number.isRequired,\n    labelTextColor: PropTypes.oneOfType([PropTypes.string, PropTypes.func]).isRequired,\n    getLabelTextColor: PropTypes.func.isRequired, // computed\n    labelLinkColor: PropTypes.oneOfType([PropTypes.string, PropTypes.func]).isRequired,\n    getLabelLinkColor: PropTypes.func.isRequired, // computed\n\n    borderRadius: PropTypes.number.isRequired,\n    getColor: PropTypes.func.isRequired }, core.defsPropTypes, {\n    borderWidth: PropTypes.number.isRequired,\n    borderColor: PropTypes.any.isRequired,\n    getBorderColor: PropTypes.func.isRequired,\n\n    isInteractive: PropTypes.bool,\n    onClick: PropTypes.func.isRequired,\n    onMouseEnter: PropTypes.func.isRequired,\n    onMouseLeave: PropTypes.func.isRequired,\n    tooltipLabel: PropTypes.func,\n    getTooltipLabel: PropTypes.func.isRequired,\n    tooltipFormat: PropTypes.oneOfType([PropTypes.func, PropTypes.string]),\n    tooltip: PropTypes.func,\n\n    legends: PropTypes.arrayOf(PropTypes.shape(_extends({\n        dataFrom: PropTypes.oneOf(['indexes', 'keys']).isRequired\n    }, legends.LegendPropShape))).isRequired,\n\n    // canvas specific\n    pixelRatio: PropTypes.number.isRequired\n});\n\nvar BarDefaultProps = {\n    indexBy: 'id',\n    keys: ['value'],\n    layers: ['grid', 'axes', 'bars', 'markers', 'legends'],\n\n    groupMode: 'stacked',\n    layout: 'vertical',\n    reverse: false,\n\n    minValue: 'auto',\n    maxValue: 'auto',\n    padding: 0.1,\n    innerPadding: 0,\n\n    axisBottom: {},\n    axisLeft: {},\n    enableGridX: false,\n    enableGridY: true,\n\n    barComponent: BarItem$1,\n\n    enableLabel: true,\n    label: 'value',\n    labelSkipWidth: 0,\n    labelSkipHeight: 0,\n    labelLinkColor: 'theme',\n    labelTextColor: 'theme',\n\n    defs: [],\n    fill: [],\n    borderRadius: 0,\n    borderWidth: 0,\n    borderColor: 'inherit',\n\n    isInteractive: true,\n    onClick: core.noop,\n    onMouseEnter: core.noop,\n    onMouseLeave: core.noop,\n\n    legends: [],\n\n    // canvas specific\n    pixelRatio: global.window && global.window.devicePixelRatio ? global.window.devicePixelRatio : 1\n};\n\nvar enhance$1 = (function (Component) {\n    return compose(defaultProps(BarDefaultProps), core.withTheme(), core.withColors(), core.withDimensions(), core.withMotion(), withPropsOnChange(['indexBy'], function (_ref) {\n        var indexBy = _ref.indexBy;\n        return {\n            getIndex: core.getAccessorFor(indexBy)\n        };\n    }), withPropsOnChange(['labelTextColor'], function (_ref2) {\n        var labelTextColor = _ref2.labelTextColor;\n        return {\n            getLabelTextColor: core.getInheritedColorGenerator(labelTextColor, 'axis.ticks.text.fill')\n        };\n    }), withPropsOnChange(['labelLinkColor'], function (_ref3) {\n        var labelLinkColor = _ref3.labelLinkColor;\n        return {\n            getLabelLinkColor: core.getInheritedColorGenerator(labelLinkColor, 'axis.ticks.line.stroke')\n        };\n    }), withPropsOnChange(['label', 'labelFormat'], function (_ref4) {\n        var label = _ref4.label,\n            labelFormat = _ref4.labelFormat;\n        return {\n            getLabel: core.getLabelGenerator(label, labelFormat)\n        };\n    }), withPropsOnChange(['borderColor'], function (_ref5) {\n        var borderColor = _ref5.borderColor;\n        return {\n            getBorderColor: core.getInheritedColorGenerator(borderColor)\n        };\n    }), withPropsOnChange(['tooltipLabel'], function (_ref6) {\n        var tooltipLabel = _ref6.tooltipLabel;\n\n        var getTooltipLabel = function getTooltipLabel(d) {\n            return d.id + ' - ' + d.indexValue;\n        };\n        if (typeof tooltipLabel === 'function') {\n            getTooltipLabel = tooltipLabel;\n        }\n\n        return { getTooltipLabel: getTooltipLabel };\n    }), pure)(Component);\n});\n\nvar barWillEnterHorizontal = function barWillEnterHorizontal(_ref) {\n    var style = _ref.style;\n    return {\n        x: style.x.val,\n        y: style.y.val,\n        width: 0,\n        height: style.height.val\n    };\n};\n\nvar barWillEnterVertical = function barWillEnterVertical(_ref2) {\n    var style = _ref2.style;\n    return {\n        x: style.x.val,\n        y: style.y.val + style.height.val,\n        width: style.width.val,\n        height: 0\n    };\n};\n\nvar barWillLeaveHorizontal = function barWillLeaveHorizontal(springConfig) {\n    return function (_ref3) {\n        var style = _ref3.style;\n        return {\n            x: style.x,\n            y: style.y,\n            width: reactMotion.spring(0, springConfig),\n            height: style.height\n        };\n    };\n};\n\nvar barWillLeaveVertical = function barWillLeaveVertical(springConfig) {\n    return function (_ref4) {\n        var style = _ref4.style;\n        return {\n            x: style.x,\n            y: reactMotion.spring(style.y.val + style.height.val, springConfig),\n            width: style.width,\n            height: reactMotion.spring(0, springConfig)\n        };\n    };\n};\n\nvar Bar = function Bar(props) {\n    var data = props.data,\n        getIndex = props.getIndex,\n        keys = props.keys,\n        groupMode = props.groupMode,\n        layout = props.layout,\n        reverse = props.reverse,\n        minValue = props.minValue,\n        maxValue = props.maxValue,\n        margin = props.margin,\n        width = props.width,\n        height = props.height,\n        outerWidth = props.outerWidth,\n        outerHeight = props.outerHeight,\n        padding = props.padding,\n        innerPadding = props.innerPadding,\n        axisTop = props.axisTop,\n        axisRight = props.axisRight,\n        axisBottom = props.axisBottom,\n        axisLeft = props.axisLeft,\n        enableGridX = props.enableGridX,\n        enableGridY = props.enableGridY,\n        gridXValues = props.gridXValues,\n        gridYValues = props.gridYValues,\n        layers = props.layers,\n        barComponent = props.barComponent,\n        enableLabel = props.enableLabel,\n        getLabel = props.getLabel,\n        labelSkipWidth = props.labelSkipWidth,\n        labelSkipHeight = props.labelSkipHeight,\n        getLabelTextColor = props.getLabelTextColor,\n        markers = props.markers,\n        theme = props.theme,\n        getColor = props.getColor,\n        defs = props.defs,\n        fill = props.fill,\n        borderRadius = props.borderRadius,\n        borderWidth = props.borderWidth,\n        getBorderColor = props.getBorderColor,\n        animate = props.animate,\n        motionStiffness = props.motionStiffness,\n        motionDamping = props.motionDamping,\n        isInteractive = props.isInteractive,\n        getTooltipLabel = props.getTooltipLabel,\n        tooltipFormat = props.tooltipFormat,\n        tooltip = props.tooltip,\n        onClick = props.onClick,\n        onMouseEnter = props.onMouseEnter,\n        onMouseLeave = props.onMouseLeave,\n        legends$$1 = props.legends;\n\n    var options = {\n        layout: layout,\n        reverse: reverse,\n        data: data,\n        getIndex: getIndex,\n        keys: keys,\n        minValue: minValue,\n        maxValue: maxValue,\n        width: width,\n        height: height,\n        getColor: getColor,\n        padding: padding,\n        innerPadding: innerPadding\n    };\n    var result = groupMode === 'grouped' ? generateGroupedBars(options) : generateStackedBars(options);\n\n    var motionProps = {\n        animate: animate,\n        motionDamping: motionDamping,\n        motionStiffness: motionStiffness\n    };\n\n    var springConfig = {\n        damping: motionDamping,\n        stiffness: motionStiffness\n    };\n\n    var willEnter = layout === 'vertical' ? barWillEnterVertical : barWillEnterHorizontal;\n    var willLeave = layout === 'vertical' ? barWillLeaveVertical(springConfig) : barWillLeaveHorizontal(springConfig);\n\n    var shouldRenderLabel = function shouldRenderLabel(_ref5) {\n        var width = _ref5.width,\n            height = _ref5.height;\n\n        if (!enableLabel) return false;\n        if (labelSkipWidth > 0 && width < labelSkipWidth) return false;\n        if (labelSkipHeight > 0 && height < labelSkipHeight) return false;\n        return true;\n    };\n\n    var boundDefs = core.bindDefs(defs, result.bars, fill, {\n        dataKey: 'data',\n        targetKey: 'data.fill'\n    });\n\n    var legendDataForKeys = result.bars.filter(function (bar) {\n        return bar.data.index === 0;\n    }).map(function (bar) {\n        return {\n            id: bar.data.id,\n            label: bar.data.id,\n            color: bar.color,\n            fill: bar.data.fill\n        };\n    }).reverse();\n\n    var legendDataForIndexes = result.bars.filter(function (bar) {\n        return bar.data.id === keys[0];\n    }).map(function (bar) {\n        return {\n            id: bar.data.indexValue,\n            label: bar.data.indexValue,\n            color: bar.color,\n            fill: bar.data.fill\n        };\n    });\n\n    return React__default.createElement(\n        core.Container,\n        { isInteractive: isInteractive, theme: theme },\n        function (_ref6) {\n            var showTooltip = _ref6.showTooltip,\n                hideTooltip = _ref6.hideTooltip;\n\n            var commonProps = {\n                borderRadius: borderRadius,\n                borderWidth: borderWidth,\n                enableLabel: enableLabel,\n                labelSkipWidth: labelSkipWidth,\n                labelSkipHeight: labelSkipHeight,\n                showTooltip: showTooltip,\n                hideTooltip: hideTooltip,\n                onClick: onClick,\n                onMouseEnter: onMouseEnter,\n                onMouseLeave: onMouseLeave,\n                theme: theme,\n                getTooltipLabel: getTooltipLabel,\n                tooltipFormat: tooltipFormat,\n                tooltip: tooltip\n            };\n\n            var bars = void 0;\n            if (animate === true) {\n                bars = React__default.createElement(\n                    reactMotion.TransitionMotion,\n                    {\n                        key: 'bars',\n                        willEnter: willEnter,\n                        willLeave: willLeave,\n                        styles: result.bars.map(function (bar) {\n                            return {\n                                key: bar.key,\n                                data: bar,\n                                style: {\n                                    x: reactMotion.spring(bar.x, springConfig),\n                                    y: reactMotion.spring(bar.y, springConfig),\n                                    width: reactMotion.spring(bar.width, springConfig),\n                                    height: reactMotion.spring(bar.height, springConfig)\n                                }\n                            };\n                        })\n                    },\n                    function (interpolatedStyles) {\n                        return React__default.createElement(\n                            'g',\n                            null,\n                            interpolatedStyles.map(function (_ref7) {\n                                var key = _ref7.key,\n                                    style = _ref7.style,\n                                    bar = _ref7.data;\n\n                                var baseProps = _extends({}, bar, style);\n\n                                return React__default.createElement(barComponent, _extends({\n                                    key: key\n                                }, baseProps, commonProps, {\n                                    shouldRenderLabel: shouldRenderLabel(baseProps),\n                                    width: Math.max(style.width, 0),\n                                    height: Math.max(style.height, 0),\n                                    label: getLabel(bar.data),\n                                    labelColor: getLabelTextColor(baseProps, theme),\n                                    borderColor: getBorderColor(baseProps),\n                                    theme: theme\n                                }));\n                            })\n                        );\n                    }\n                );\n            } else {\n                bars = result.bars.map(function (d) {\n                    return React__default.createElement(barComponent, _extends({\n                        key: d.key\n                    }, d, commonProps, {\n                        label: getLabel(d.data),\n                        shouldRenderLabel: shouldRenderLabel(d),\n                        labelColor: getLabelTextColor(d, theme),\n                        borderColor: getBorderColor(d),\n                        theme: theme\n                    }));\n                });\n            }\n\n            var layerById = {\n                grid: React__default.createElement(core.Grid, _extends({\n                    key: 'grid',\n                    theme: theme,\n                    width: width,\n                    height: height,\n                    xScale: enableGridX ? result.xScale : null,\n                    yScale: enableGridY ? result.yScale : null,\n                    xValues: gridXValues,\n                    yValues: gridYValues\n                }, motionProps)),\n                axes: React__default.createElement(axes.Axes, _extends({\n                    key: 'axes',\n                    xScale: result.xScale,\n                    yScale: result.yScale,\n                    width: width,\n                    height: height,\n                    theme: theme,\n                    top: axisTop,\n                    right: axisRight,\n                    bottom: axisBottom,\n                    left: axisLeft\n                }, motionProps)),\n                bars: bars,\n                markers: React__default.createElement(core.CartesianMarkers, {\n                    key: 'markers',\n                    markers: markers,\n                    width: width,\n                    height: height,\n                    xScale: result.xScale,\n                    yScale: result.yScale,\n                    theme: theme\n                }),\n                legends: legends$$1.map(function (legend, i) {\n                    var legendData = void 0;\n                    if (legend.dataFrom === 'keys') {\n                        legendData = legendDataForKeys;\n                    } else if (legend.dataFrom === 'indexes') {\n                        legendData = legendDataForIndexes;\n                    }\n\n                    if (legendData === undefined) return null;\n\n                    return React__default.createElement(legends.BoxLegendSvg, _extends({\n                        key: i\n                    }, legend, {\n                        containerWidth: width,\n                        containerHeight: height,\n                        data: legendData,\n                        theme: theme\n                    }));\n                })\n            };\n\n            return React__default.createElement(\n                core.SvgWrapper,\n                {\n                    width: outerWidth,\n                    height: outerHeight,\n                    margin: margin,\n                    defs: boundDefs,\n                    theme: theme\n                },\n                layers.map(function (layer, i) {\n                    if (typeof layer === 'function') {\n                        return React__default.createElement(\n                            React.Fragment,\n                            { key: i },\n                            layer(_extends({}, props, result))\n                        );\n                    }\n                    return layerById[layer];\n                })\n            );\n        }\n    );\n};\n\nBar.propTypes = BarPropTypes;\n\nvar Bar$1 = setDisplayName('Bar')(enhance$1(Bar));\n\nvar findNodeUnderCursor = function findNodeUnderCursor(nodes, margin, x, y) {\n    return nodes.find(function (node) {\n        return core.isCursorInRect(node.x + margin.left, node.y + margin.top, node.width, node.height, x, y);\n    });\n};\n\nvar BarCanvas = function (_Component) {\n    inherits(BarCanvas, _Component);\n\n    function BarCanvas() {\n        var _temp, _this, _ret;\n\n        classCallCheck(this, BarCanvas);\n\n        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n            args[_key] = arguments[_key];\n        }\n\n        return _ret = (_temp = (_this = possibleConstructorReturn(this, _Component.call.apply(_Component, [this].concat(args))), _this), _this.handleMouseHover = function (showTooltip, hideTooltip) {\n            return function (event) {\n                if (!_this.bars) return;\n\n                var _this$props = _this.props,\n                    margin = _this$props.margin,\n                    theme = _this$props.theme,\n                    tooltip = _this$props.tooltip,\n                    getTooltipLabel = _this$props.getTooltipLabel,\n                    tooltipFormat = _this$props.tooltipFormat;\n\n                var _getRelativeCursor = core.getRelativeCursor(_this.surface, event),\n                    x = _getRelativeCursor[0],\n                    y = _getRelativeCursor[1];\n\n                var bar = findNodeUnderCursor(_this.bars, margin, x, y);\n\n                if (bar !== undefined) {\n                    showTooltip(React__default.createElement(core.BasicTooltip, {\n                        id: getTooltipLabel(bar.data),\n                        value: bar.data.value,\n                        enableChip: true,\n                        color: bar.color,\n                        theme: theme,\n                        format: tooltipFormat,\n                        renderContent: typeof tooltip === 'function' ? tooltip.bind(null, _extends({ color: bar.color }, bar.data)) : null\n                    }), event);\n                } else {\n                    hideTooltip();\n                }\n            };\n        }, _this.handleMouseLeave = function (hideTooltip) {\n            return function () {\n                hideTooltip();\n            };\n        }, _this.handleClick = function (event) {\n            if (!_this.bars) return;\n\n            var _this$props2 = _this.props,\n                margin = _this$props2.margin,\n                onClick = _this$props2.onClick;\n\n            var _getRelativeCursor2 = core.getRelativeCursor(_this.surface, event),\n                x = _getRelativeCursor2[0],\n                y = _getRelativeCursor2[1];\n\n            var node = findNodeUnderCursor(_this.bars, margin, x, y);\n            if (node !== undefined) onClick(node.data, event);\n        }, _temp), possibleConstructorReturn(_this, _ret);\n    }\n\n    BarCanvas.prototype.componentDidMount = function componentDidMount() {\n        this.ctx = this.surface.getContext('2d');\n        this.draw(this.props);\n    };\n\n    BarCanvas.prototype.shouldComponentUpdate = function shouldComponentUpdate(props) {\n        if (this.props.outerWidth !== props.outerWidth || this.props.outerHeight !== props.outerHeight || this.props.isInteractive !== props.isInteractive || this.props.theme !== props.theme) {\n            return true;\n        } else {\n            this.draw(props);\n            return false;\n        }\n    };\n\n    BarCanvas.prototype.componentDidUpdate = function componentDidUpdate() {\n        this.ctx = this.surface.getContext('2d');\n        this.draw(this.props);\n    };\n\n    BarCanvas.prototype.draw = function draw(props) {\n        var _this2 = this;\n\n        var data = props.data,\n            keys = props.keys,\n            getIndex = props.getIndex,\n            minValue = props.minValue,\n            maxValue = props.maxValue,\n            width = props.width,\n            height = props.height,\n            outerWidth = props.outerWidth,\n            outerHeight = props.outerHeight,\n            pixelRatio = props.pixelRatio,\n            margin = props.margin,\n            layout = props.layout,\n            reverse = props.reverse,\n            groupMode = props.groupMode,\n            padding = props.padding,\n            innerPadding = props.innerPadding,\n            axisTop = props.axisTop,\n            axisRight = props.axisRight,\n            axisBottom = props.axisBottom,\n            axisLeft = props.axisLeft,\n            theme = props.theme,\n            getColor = props.getColor,\n            legends$$1 = props.legends,\n            enableGridX = props.enableGridX,\n            enableGridY = props.enableGridY;\n\n\n        this.surface.width = outerWidth * pixelRatio;\n        this.surface.height = outerHeight * pixelRatio;\n\n        this.ctx.scale(pixelRatio, pixelRatio);\n\n        var options = {\n            layout: layout,\n            reverse: reverse,\n            data: data,\n            getIndex: getIndex,\n            keys: keys,\n            minValue: minValue,\n            maxValue: maxValue,\n            width: width,\n            height: height,\n            getColor: getColor,\n            padding: padding,\n            innerPadding: innerPadding\n        };\n\n        var result = groupMode === 'grouped' ? generateGroupedBars(options) : generateStackedBars(options);\n\n        this.bars = result.bars;\n\n        this.ctx.fillStyle = theme.background;\n        this.ctx.fillRect(0, 0, outerWidth, outerHeight);\n        this.ctx.translate(margin.left, margin.top);\n\n        this.ctx.strokeStyle = '#dddddd';\n        enableGridX && core.renderGridLinesToCanvas(this.ctx, {\n            width: width,\n            height: height,\n            scale: result.xScale,\n            axis: 'x'\n        });\n        enableGridY && core.renderGridLinesToCanvas(this.ctx, {\n            width: width,\n            height: height,\n            scale: result.yScale,\n            axis: 'y'\n        });\n\n        this.ctx.strokeStyle = '#dddddd';\n        var legendDataForKeys = result.bars.filter(function (bar) {\n            return bar.data.index === 0;\n        }).map(function (bar) {\n            return {\n                id: bar.data.id,\n                label: bar.data.id,\n                color: bar.color,\n                fill: bar.data.fill\n            };\n        }).reverse();\n        var legendDataForIndexes = result.bars.filter(function (bar) {\n            return bar.data.id === keys[0];\n        }).map(function (bar) {\n            return {\n                id: bar.data.indexValue,\n                label: bar.data.indexValue,\n                color: bar.color,\n                fill: bar.data.fill\n            };\n        });\n\n        legends$$1.forEach(function (legend) {\n            var legendData = void 0;\n            if (legend.dataFrom === 'keys') {\n                legendData = legendDataForKeys;\n            } else if (legend.dataFrom === 'indexes') {\n                legendData = legendDataForIndexes;\n            }\n\n            if (legendData === undefined) return null;\n            legends.renderLegendToCanvas(_this2.ctx, _extends({}, legend, {\n                data: legendData,\n                containerWidth: width,\n                containerHeight: height,\n                itemTextColor: '#999',\n                symbolSize: 16\n            }));\n        });\n\n        core.renderAxesToCanvas(this.ctx, {\n            xScale: result.xScale,\n            yScale: result.yScale,\n            width: width,\n            height: height,\n            top: axisTop,\n            right: axisRight,\n            bottom: axisBottom,\n            left: axisLeft,\n            theme: theme\n        });\n\n        result.bars.forEach(function (_ref) {\n            var x = _ref.x,\n                y = _ref.y,\n                color = _ref.color,\n                width = _ref.width,\n                height = _ref.height;\n\n            _this2.ctx.fillStyle = color;\n            _this2.ctx.fillRect(x, y, width, height);\n        });\n    };\n\n    BarCanvas.prototype.render = function render() {\n        var _this3 = this;\n\n        var _props = this.props,\n            outerWidth = _props.outerWidth,\n            outerHeight = _props.outerHeight,\n            pixelRatio = _props.pixelRatio,\n            isInteractive = _props.isInteractive,\n            theme = _props.theme;\n\n\n        return React__default.createElement(\n            core.Container,\n            { isInteractive: isInteractive, theme: theme },\n            function (_ref2) {\n                var showTooltip = _ref2.showTooltip,\n                    hideTooltip = _ref2.hideTooltip;\n                return React__default.createElement('canvas', {\n                    ref: function ref(surface) {\n                        _this3.surface = surface;\n                    },\n                    width: outerWidth * pixelRatio,\n                    height: outerHeight * pixelRatio,\n                    style: {\n                        width: outerWidth,\n                        height: outerHeight\n                    },\n                    onMouseEnter: _this3.handleMouseHover(showTooltip, hideTooltip),\n                    onMouseMove: _this3.handleMouseHover(showTooltip, hideTooltip),\n                    onMouseLeave: _this3.handleMouseLeave(hideTooltip),\n                    onClick: _this3.handleClick\n                });\n            }\n        );\n    };\n\n    return BarCanvas;\n}(React.Component);\n\nBarCanvas.propTypes = BarPropTypes;\n\nvar BarCanvas$1 = setDisplayName('BarCanvas')(enhance$1(BarCanvas));\n\nvar ResponsiveBar = function ResponsiveBar(props) {\n    return React__default.createElement(\n        core.ResponsiveWrapper,\n        null,\n        function (_ref) {\n            var width = _ref.width,\n                height = _ref.height;\n            return React__default.createElement(Bar$1, _extends({ width: width, height: height }, props));\n        }\n    );\n};\n\nvar ResponsiveBarCanvas = function ResponsiveBarCanvas(props) {\n    return React__default.createElement(\n        core.ResponsiveWrapper,\n        null,\n        function (_ref) {\n            var width = _ref.width,\n                height = _ref.height;\n            return React__default.createElement(BarCanvas$1, _extends({ width: width, height: height }, props));\n        }\n    );\n};\n\nexports.Bar = Bar$1;\nexports.BarCanvas = BarCanvas$1;\nexports.ResponsiveBar = ResponsiveBar;\nexports.ResponsiveBarCanvas = ResponsiveBarCanvas;\nexports.BarPropTypes = BarPropTypes;\nexports.BarDefaultProps = BarDefaultProps;\n","module.exports = require('./cjs/nivo-bar')\n","var isSymbol = require('./isSymbol');\n\n/**\n * The base implementation of methods like `_.max` and `_.min` which accepts a\n * `comparator` to determine the extremum value.\n *\n * @private\n * @param {Array} array The array to iterate over.\n * @param {Function} iteratee The iteratee invoked per iteration.\n * @param {Function} comparator The comparator used to compare values.\n * @returns {*} Returns the extremum value.\n */\nfunction baseExtremum(array, iteratee, comparator) {\n  var index = -1,\n      length = array.length;\n\n  while (++index < length) {\n    var value = array[index],\n        current = iteratee(value);\n\n    if (current != null && (computed === undefined\n          ? (current === current && !isSymbol(current))\n          : comparator(current, computed)\n        )) {\n      var computed = current,\n          result = value;\n    }\n  }\n  return result;\n}\n\nmodule.exports = baseExtremum;\n","/**\n * The base implementation of `_.gt` which doesn't coerce arguments.\n *\n * @private\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @returns {boolean} Returns `true` if `value` is greater than `other`,\n *  else `false`.\n */\nfunction baseGt(value, other) {\n  return value > other;\n}\n\nmodule.exports = baseGt;\n","/**\n * The base implementation of `_.lt` which doesn't coerce arguments.\n *\n * @private\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @returns {boolean} Returns `true` if `value` is less than `other`,\n *  else `false`.\n */\nfunction baseLt(value, other) {\n  return value < other;\n}\n\nmodule.exports = baseLt;\n","/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeCeil = Math.ceil,\n    nativeMax = Math.max;\n\n/**\n * The base implementation of `_.range` and `_.rangeRight` which doesn't\n * coerce arguments.\n *\n * @private\n * @param {number} start The start of the range.\n * @param {number} end The end of the range.\n * @param {number} step The value to increment or decrement by.\n * @param {boolean} [fromRight] Specify iterating from right to left.\n * @returns {Array} Returns the range of numbers.\n */\nfunction baseRange(start, end, step, fromRight) {\n  var index = -1,\n      length = nativeMax(nativeCeil((end - start) / (step || 1)), 0),\n      result = Array(length);\n\n  while (length--) {\n    result[fromRight ? length : ++index] = start;\n    start += step;\n  }\n  return result;\n}\n\nmodule.exports = baseRange;\n","var baseRange = require('./_baseRange'),\n    isIterateeCall = require('./_isIterateeCall'),\n    toFinite = require('./toFinite');\n\n/**\n * Creates a `_.range` or `_.rangeRight` function.\n *\n * @private\n * @param {boolean} [fromRight] Specify iterating from right to left.\n * @returns {Function} Returns the new range function.\n */\nfunction createRange(fromRight) {\n  return function(start, end, step) {\n    if (step && typeof step != 'number' && isIterateeCall(start, end, step)) {\n      end = step = undefined;\n    }\n    // Ensure the sign of `-0` is preserved.\n    start = toFinite(start);\n    if (end === undefined) {\n      end = start;\n      start = 0;\n    } else {\n      end = toFinite(end);\n    }\n    step = step === undefined ? (start < end ? 1 : -1) : toFinite(step);\n    return baseRange(start, end, step, fromRight);\n  };\n}\n\nmodule.exports = createRange;\n","var baseFlatten = require('./_baseFlatten'),\n    toInteger = require('./toInteger');\n\n/**\n * Recursively flatten `array` up to `depth` times.\n *\n * @static\n * @memberOf _\n * @since 4.4.0\n * @category Array\n * @param {Array} array The array to flatten.\n * @param {number} [depth=1] The maximum recursion depth.\n * @returns {Array} Returns the new flattened array.\n * @example\n *\n * var array = [1, [2, [3, [4]], 5]];\n *\n * _.flattenDepth(array, 1);\n * // => [1, 2, [3, [4]], 5]\n *\n * _.flattenDepth(array, 2);\n * // => [1, 2, 3, [4], 5]\n */\nfunction flattenDepth(array, depth) {\n  var length = array == null ? 0 : array.length;\n  if (!length) {\n    return [];\n  }\n  depth = depth === undefined ? 1 : toInteger(depth);\n  return baseFlatten(array, depth);\n}\n\nmodule.exports = flattenDepth;\n","var baseExtremum = require('./_baseExtremum'),\n    baseGt = require('./_baseGt'),\n    identity = require('./identity');\n\n/**\n * Computes the maximum value of `array`. If `array` is empty or falsey,\n * `undefined` is returned.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Math\n * @param {Array} array The array to iterate over.\n * @returns {*} Returns the maximum value.\n * @example\n *\n * _.max([4, 2, 8, 6]);\n * // => 8\n *\n * _.max([]);\n * // => undefined\n */\nfunction max(array) {\n  return (array && array.length)\n    ? baseExtremum(array, identity, baseGt)\n    : undefined;\n}\n\nmodule.exports = max;\n","var baseExtremum = require('./_baseExtremum'),\n    baseLt = require('./_baseLt'),\n    identity = require('./identity');\n\n/**\n * Computes the minimum value of `array`. If `array` is empty or falsey,\n * `undefined` is returned.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Math\n * @param {Array} array The array to iterate over.\n * @returns {*} Returns the minimum value.\n * @example\n *\n * _.min([4, 2, 8, 6]);\n * // => 2\n *\n * _.min([]);\n * // => undefined\n */\nfunction min(array) {\n  return (array && array.length)\n    ? baseExtremum(array, identity, baseLt)\n    : undefined;\n}\n\nmodule.exports = min;\n","var createRange = require('./_createRange');\n\n/**\n * Creates an array of numbers (positive and/or negative) progressing from\n * `start` up to, but not including, `end`. A step of `-1` is used if a negative\n * `start` is specified without an `end` or `step`. If `end` is not specified,\n * it's set to `start` with `start` then set to `0`.\n *\n * **Note:** JavaScript follows the IEEE-754 standard for resolving\n * floating-point values which can produce unexpected results.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Util\n * @param {number} [start=0] The start of the range.\n * @param {number} end The end of the range.\n * @param {number} [step=1] The value to increment or decrement by.\n * @returns {Array} Returns the range of numbers.\n * @see _.inRange, _.rangeRight\n * @example\n *\n * _.range(4);\n * // => [0, 1, 2, 3]\n *\n * _.range(-4);\n * // => [0, -1, -2, -3]\n *\n * _.range(1, 5);\n * // => [1, 2, 3, 4]\n *\n * _.range(0, 20, 5);\n * // => [0, 5, 10, 15]\n *\n * _.range(0, -4, -1);\n * // => [0, -1, -2, -3]\n *\n * _.range(1, 4, 0);\n * // => [1, 1, 1]\n *\n * _.range(0);\n * // => []\n */\nvar range = createRange();\n\nmodule.exports = range;\n","import Layout from '../components/MyLayout.js'\nimport SectorBar from '../components/sectorBar';\n\nconst Bar = (props) => (\n  <Layout>\n    <h1>Sankey</h1>\n    <h2>Projets</h2>\n    <div style={{height: '500px'}}>\n        <SectorBar />\n    </div>\n    <p> Ce type de graphe n'apporte pas une lecture très intéressante car on peut seulement suivre les flux deux à deux.\n    Par exemple, impossible de savoir quel projet parmi ceux financés par l'ANR a une durée de 30 à 48 mois et touche 5 structures.\n    On peut seulement savoir que parmi les projet de 5 à 10 millions, 100 durent plus de 60 mois.\n    Il faudrait n'avoir que deux niveaux et choisir quoi comparer par exemple type de financement vs montant ou alors durée etc.\n    <br />\n    <br />\n    <strong> Remarques : </strong>\n    <ul>\n      <li>\n        La clé 'color' dans les 'nodes' n'est utilisée que pour les liens.\n        Elle n'est pas obligatoire (sinon c'est la props 'colors' qui est appliquée)\n      </li>\n      <li>\n        S'il y a des espaces dans l'id d'un node, le degradé sur les liens (enableLinkGradient={true}) n'est pas possible\n      </li>\n    </ul>\n\n    <strong>Problématique qui reste à résoudre</strong>\n    <ul>\n      <li> 1. Gérer l'ordre des nodes (je ne comprends pas l'ordre par défaut) </li>\n      <li> 2. Personnalisation des labels </li>\n    </ul>\n    </p>\n  </Layout>\n)\n\nexport default Bar\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAbA;AAgBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAbA;AAgBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAbA;AAgBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAbA;AAgBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAbA;AAgBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAbA;AAgBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAbA;AACA;AAgBA;AAAA;AAEA;AACA;AAQA;AACA;AACA;AACA;AACA;AACA;AAJA;AAMA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAPA;AAUA;AACA;AACA;AACA;AACA;AACA;AACA;AAPA;AAUA;AAEA;AACA;AADA;AAGA;AAJA;AAOA;AACA;AADA;AAGA;AAJA;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AANA;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AANA;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AADA;AAFA;AAdA;AAhFA;AADA;AACA;AA0GA;;;;;;;;;;;;AC1NA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AChtBA;;;;;;;;;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC/4CA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC/BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;ACbA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACbA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC3BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC7BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;AChCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC5BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC5BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC7CA;AACA;AACA;AACA;AAAA;AAIA;AAAA;AAAA;AAAA;AAJA;AACA;AAgCA;;;;;;;;;;;;;;;;;;;;;;;A","sourceRoot":""}